<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pyIFD.CAGI API documentation</title>
<meta name="description" content="This module provides the CAGI algorithm" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyIFD.CAGI</code></h1>
</header>
<section id="section-intro">
<p>This module provides the CAGI algorithm</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module provides the CAGI algorithm
&#34;&#34;&#34;

from PIL import Image
from skimage.color import rgb2gray
import numpy as np
from scipy.ndimage import correlate
import cv2
from scipy import signal
from skimage.transform import resize
import math
import os 

def im2double(im):
    &#34;&#34;&#34;
    Converts image to type double.

    Args:
        im: Input image

    Returns: 
        image as double: Converts type of im to double. Scales so elements lie from 0 to 1.
    &#34;&#34;&#34;
    info = np.iinfo(im.dtype) 
    return im.astype(np.double) / info.max 

def ImageTiling(OImg):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        OImg:

    Returns:
        tile:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    Img = np.array(Image.fromarray(OImg.astype(np.uint8)).resize(size=(600,600),resample=Image.NEAREST))
    R1=rgb2gray(Img)
    R=R1*255


    blocks=3600
    stepX=60
    stepY=60
    ImgR=R.astype(&#39;int&#39;)

    countx=-1
    tile=np.zeros((10,10,blocks))
    for a in range(stepX):
        for b in range(stepY):
            countx+=1
            i=-1
            for x in range((a*10),(a*10)+10):
                i+=1
                j=-1
                for y in range((b*10),(b*10)+10):
                    j+=1;
                    tile[i,j,countx]=ImgR[x,y]
                    
    return tile

def MainTrain(R10,blk_idx,blk_idy):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        R10:
        blk_idx:
        blk_idy:

    Returns:
        MeanContent:
        MeanStrongEdge:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    [x,y,z]=R10.shape
    [PMasks,MMasks,MaskWhite] = getMasks()
    #////////Image Tiling 3 Scales////////////////////////////
    #slight difference in tileF (~99% similarity)
    tileF=ImageTiling(R10)

    #////////////Smaping/////////////////////////////////////
    smapF=SmapIng(tileF, PMasks, MaskWhite)
    #% % % %////////////Filtering///////////////////////////////////
    [ThresSmall,ThresBig, ThresImg] =filtering(smapF)
    smapF_filtrOld=filteringMethod(smapF, ThresSmall, ThresBig, ThresImg)
    #Through here so far
    #/////////////PaintEdges///////////////////////////////// This uses NN PIL using mean
    [e,edge,contours]=PaintimgEdges(smapF_filtrOld, MMasks, 1)
    Output = np.array(Image.fromarray(e.astype(np.double)).resize(size=(y,x),resample=Image.NEAREST))
    StrongEdge = np.array(Image.fromarray(contours.astype(np.uint8)).resize(size=(y,x),resample=Image.NEAREST))


    MeanContent = np.zeros((blk_idx,blk_idy))
    MeanStrongEdge = np.zeros((blk_idx,blk_idy))
    for i in range(blk_idx):
        for j in range(blk_idy):
            a=i*8
            b=j*8
            MeanContent[i,j]=np.mean(Output[a:a+8, b:b+8])
            MeanStrongEdge[i,j]=np.mean(StrongEdge[a:a+8, b:b+8])
    MeanStrongEdge[MeanStrongEdge&gt;0.5]=1

    MeanStrongEdge[MeanStrongEdge&lt;=0.5]=0 
        

    return [MeanContent,MeanStrongEdge]

def PaintimgEdges(smap, MMasks, scale):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        smap:
        MMasks:
        scale:

    Returns:
        edgeImg2:
        edgeImg:
        edgeImg3:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    if (scale==1):
        blocks=3600
        stepX=60
 
    edgeImg=np.zeros((600,600))
    edgeImg2=np.zeros((600,600))
    edgeImg3=np.zeros((600,600))
    countx=-1
    for a in range(stepX):
        for b in range(stepX):
            countx+=1
            i=-1
            for x in range(a*10,a*10+10):
                i+=1
                j=-1
                for y in range(b*10,b*10+10):
                    j+=1
                    edgeImg[x,y]=MMasks[i,j,int(smap[countx,0]-1)];
                    if (smap[countx,0]==59):
                        edgeImg3[x,y]=0
                    else:
                         edgeImg3[x,y]=1
                    edgeImg2[x,y]=smap[countx,1]
                    
    return [edgeImg2, edgeImg,edgeImg3]

def RescaleToImageResult(E,sgrid,kx,ky,pixels):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        E:
        sgrid:
        kx:
        ky:
        pixels:

    Returns:
        Result:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    result = np.zeros((kx*sgrid*8,ky*sgrid*8))
    for x in range(kx):
        for y in range(ky):
            a=x*sgrid*8
            b=y*sgrid*8
            result[a:a+sgrid*8,b:b+sgrid*8]  = E[x,y]
    [xim, yim]=pixels.shape
    [xres, yres]=result.shape
    Result=np.zeros((xim,yim))
    Result[:xres,:yres]=result

    for  k in range(xres,xim):
        for y in range(yres):
            Result[k, y]=result[xres-1,y]

    for k in range(xim):
        for y in range(yres,yim):
            Result[k, y]=Result[k,yres-1] # TODO Review yres here

    return Result

def SmapIng(ImgTiles, MaskTiles, WhiteMaskPoints):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        ImgTiles:
        MaskTiles:
        WhiteMaskPoints:

    Returns:
        smap:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    blocks=np.shape(ImgTiles)[2]
    smap=np.zeros((blocks,2))
    winMask=59
    MaskWhite = (MaskTiles&gt;0).astype(int)
    MaskBlack = (MaskTiles&lt;=0).astype(int)

    for a in range(blocks): 
        maxR=0
        for k in range(58): 
            TempW = np.sum(ImgTiles[:,:,a]*MaskWhite[:,:,k])
            TempB = np.sum(ImgTiles[:,:,a]*MaskBlack[:,:,k])
            whiteScore=TempW/WhiteMaskPoints[k]
            blackScore=TempB/(100-WhiteMaskPoints[k])
            ctR=np.abs(whiteScore-blackScore)
            w=((ctR*100)/255)
            if (w&gt;maxR):
                maxR=w
                winMask=k+1

        smap[a,0]=winMask
        smap[a,1]=maxR

    return smap

def mat2gray(A):
    &#34;&#34;&#34;
    Converts matrix to have values from 0-1.

    Args:
        A: Input matrix.

    Returns:
        Gray matrix with values from 0-1.

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    A-=A.min()
    if(A.max()==0):
        return A
    return A/A.max()


def characterizeblocks(MeanContent2,MeanStrongEdge, V_im, blk_idx,blk_idy, MeanInSpace,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv,sgrid,PossiblePoints,kx,ky):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        MeanContent2:
        MeanStrongEdge:
        V_im:
        blk_idx:
        blk_idy:
        MeanInSpace:
        diff_Mean_Best_scaled:
        diff_Mean_Best_scaledInv:
        sgrid:
        PossiblePoints:
        kx:
        ky:

    Returns:
        E:
        EInv:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    uniform=np.zeros((int(np.floor(blk_idx/sgrid)),int(np.floor(blk_idy/sgrid))))

    for a in range(kx):
        for b in range(ky):
            for pp in range(16):
                if (MeanInSpace[a,b,pp]&lt;(np.mean(MeanInSpace[:,:,pp]) *0.2)):
                    uniform[a,b]+=1
    
    st=np.std(np.reshape(uniform,(uniform.size,1),&#39;F&#39;))
    H =  np.ones((5,5))*0.04
    
    I=correlate(uniform,H,mode=&#39;constant&#39;)
    meanv=np.mean(I)             


    bg=0
    for f in range(16):
        if ((PossiblePoints[f,0]==4) and (PossiblePoints[f,1]==4)):
            bg=f+1
      
    if bg==16:
        bestgrid=mat2gray(correlate(MeanInSpace[:,:,15],H,mode=&#39;constant&#39;))
    elif bg==0:            
        bg1= np.where(PossiblePoints[:,4]==max(PossiblePoints[:,4]))  
        bg=np.max(bg1)+1
        bestgrid=mat2gray(correlate(MeanInSpace[:,:,bg-1],H,mode=&#39;constant&#39;))
    else:          
        bestgrid=mat2gray(correlate(MeanInSpace[:,:,bg],H,mode=&#39;constant&#39;))
#//////////block based homogenous
    if ((np.mean(PossiblePoints[:,4])&gt;0.4)  or (bg!=16)):
        homB=0
    else:
        homB=1
  
    if ((st/meanv)&gt;1.5):
        I[I&lt;(meanv+(st))]=0
        I[I&gt;=(meanv+(st))]=homB
    else:
        I[I&lt;(meanv+(st)/2)]=0
        I[I&gt;=(meanv+(st)/2)]=homB


#/////////no content////////////////////////


    contentsc=MeanContent2.copy()

    x24=np.floor(blk_idx/3)
    y24=np.floor(blk_idy/3)

    hom=np.zeros((kx,ky))
    held=np.mean(contentsc)
    for i in range(kx):
        for j in range(ky):
            if (contentsc[i,j]&lt;=4): #very soft responses
                hom[i,j]=1

    c=sgrid
    MeanStrongEdge2=np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
            a=i*sgrid
            b=j*sgrid
            MeanStrongEdge2[i,j]=np.mean(MeanStrongEdge[a:a+c, b:b+c])
    cc=8*sgrid
    V_im2=np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
            a=i*8*sgrid
            b=j*8*sgrid
            V_im2[i,j]=np.mean(V_im[a:a+cc, b:b+cc])

    V_imOver=V_im2.copy()
    V_imUndr=V_im2.copy()
    V_imOver[V_imOver&gt;=245]=300
    V_imOver[V_imOver!=300]=0
    V_imUndr[V_imUndr&lt;15]=300
    V_imUndr[V_imUndr!=300]=0
    V_imOver=mat2gray(V_imOver)
    V_imUndr=mat2gray(V_imUndr)
    MeanStrongEdge2[MeanStrongEdge2&lt;0.5]=0
    MeanStrongEdge2[MeanStrongEdge2&gt;=0.5]=1
    #/////////////end overexposed/iunder and contours////////////////////

    touse=kx*ky
    notuse=np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
      
            if hom[i,j]==1:
                notuse[i,j]=3
            if MeanStrongEdge2[i,j]==1:
                notuse[i,j]=2         
            if ((V_imUndr[i,j]==1) or (V_imOver[i,j]==1)):
                notuse[i,j]=1

    for i in range(kx):
        for j in range(ky):   
            if notuse[i,j]==1:
                I[i,j]=1
    
    notused=np.sum(notuse[:]!=0)
    touse=kx*ky-notused
#//////////////excl NaN

    if touse==0:
        for i in range(kx):
            for j in range(ky):
                if  hom[i,j]==1 and I[i,j]!=1:
                    notuse[i,j]=0

    diff_Mean_Best_scaled_temp=diff_Mean_Best_scaled.copy()
    diff_Mean_Best_scaled_tempInv=diff_Mean_Best_scaledInv.copy()
    for a in range(int(np.floor(blk_idx/sgrid))):
        for b in range(int(np.floor(blk_idy/sgrid))):
            if I[a,b]==1:
                diff_Mean_Best_scaled_temp[a,b]=0
                diff_Mean_Best_scaled_tempInv[a,b]=1
            if diff_Mean_Best_scaled_temp[a,b]&lt;np.mean(diff_Mean_Best_scaled) and homB==1:
                diff_Mean_Best_scaled_temp[a,b]=0
            if diff_Mean_Best_scaled_tempInv[a,b]&lt;np.mean(diff_Mean_Best_scaledInv)and homB==1:
                diff_Mean_Best_scaled_tempInv[a,b]=1

    a+=1
    b+=1
    imageF = np.zeros((a,b))
    imageFInv = np.zeros((a,b))
    for x in range(a):
        for y in range(b):
            if x==0 or x==a-1 or y==0 or y==b-1:
                imageF[x,y]=diff_Mean_Best_scaled_temp[x,y]*(bestgrid[x,y])
            else:
                imageF[x,y]=diff_Mean_Best_scaled_temp[x,y]*(1-bestgrid[x,y])
            imageFInv[x,y]=diff_Mean_Best_scaled_tempInv[x,y]*(1-bestgrid[x,y])
         
    E_nofilt=imageF.copy()
    E=correlate(imageF, H,mode=&#39;constant&#39;)
          
    E_nofiltInv=imageFInv.copy()
    EInv=correlate(imageFInv, H,mode=&#39;constant&#39;)
    # /////////////content based filtering//////////
    uninteresting=np.zeros((touse,1))
    uninterestingInv=np.zeros((touse,1))
    a=-1
    for i in range(kx):
        for j in range(ky):
            if(notuse[i,j]==0):
                a+=1
                uninteresting[a]=E[i,j]
                uninterestingInv[a]=EInv[i,j] 
    MeanBlocksre=E_nofilt.copy()
    MeanBlocksreInv=E_nofiltInv.copy()
    meanuninteresting=np.mean(uninteresting)
    meanuninterestingInv=np.mean(uninterestingInv)
    for i in range(kx):
        for j in range(ky):
            if ((I[i,j]==1) and (notuse[i,j]==2)):
                I[i,j]=0
            if ((notuse[i,j]==1) or (MeanBlocksre[i,j]&lt;meanuninteresting)):
                MeanBlocksre[i,j]=meanuninteresting
            if (((I[i,j]==1) and (MeanBlocksre[i,j]&lt;meanuninteresting )) or  ((notuse[i,j]==3) and (I[i,j]==1))):
                MeanBlocksre[i,j]=meanuninteresting
            if ((notuse[i,j]==1) or (MeanBlocksreInv[i,j]&gt;meanuninterestingInv)):
                MeanBlocksreInv[i,j]=meanuninterestingInv
            if (((I[i,j]==1)  and (MeanBlocksreInv[i,j]&gt;meanuninterestingInv)) or ((notuse[i,j]==3) and (I[i,j]==1))):
                MeanBlocksreInv[i,j]=meanuninterestingInv
    E=correlate(MeanBlocksre, H,mode=&#39;reflect&#39;) 
    EInv=correlate(MeanBlocksreInv, H,mode=&#39;reflect&#39;) 
            
    return [E, EInv]

blocksize = 6

def filtering(smap):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        smap:

    Returns:
        meansmallAreas:
        meanbigAreas:
        meanImg: 

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    blocks=np.shape(smap)[0]
    step=np.int(np.sqrt(blocks))
    smallAreas=np.zeros((blocksize,blocksize))
    increment=np.int(step/blocksize)
    for a in range(blocksize):
        Start=np.int((a+1)*(blocks/blocksize)-(blocks/blocksize)+1)
        End=np.int((a+1)*(blocks/blocksize))
        for x in range(Start,End,step):
            for y in range(increment):
                z=x+y-1
                if (a&lt;3):
                    smallAreas[0,a*2]=smallAreas[0,a*2]+smap[z,1]
                    smallAreas[0,a*2+1]=smallAreas[0,a*2+1]+smap[z+increment,1]

                    smallAreas[1,(a*2)]=smallAreas[1,(a*2)]+smap[z+2*(increment),1]
                    smallAreas[1,a*2+1]=smallAreas[1,a*2+1]+smap[z+3*(increment),1]
                
                    smallAreas[2,a*2]=smallAreas[2,a*2]+smap[z+4*(increment),1]
                    smallAreas[2,a*2+1]=smallAreas[2,a*2+1]+smap[z+5*(increment),1]
                else: 
                    smallAreas[3,((a-3)*2)]=smallAreas[3,((a-3)*2)]+smap[z,1]
                    smallAreas[3,(a-3)*2+1]=smallAreas[3,(a-3)*2+1]+smap[z+increment,1]
                
                    smallAreas[4,((a-3)*2)]=smallAreas[4,((a-3)*2)]+smap[z+2*(increment),1]
                    smallAreas[4,(a-3)*2+1]=smallAreas[4,(a-3)*2+1]+smap[z+3*(increment),1]
                
                    smallAreas[5,((a-3)*2)]=smallAreas[5,((a-3)*2)]+smap[z+4*(increment),1]
                    smallAreas[5,(a-3)*2+1]=smallAreas[5,(a-3)*2+1]+smap[z+5*(increment),1]
    meansmallAreas=smallAreas/100
    meanbigAreas=np.zeros((1,blocksize))
    for x in range(blocksize):
        meanbigAreas[0,x]=np.mean(meansmallAreas[x,:])
    meanImg=np.mean(meanbigAreas)

    return [meansmallAreas, meanbigAreas, meanImg]

blocksize = 6

def filteringMethod (smap, ThressSmall, ThressBigV, ThressImg):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        smap:
        ThressSmall:
        ThressBigV:
        ThressImg:

    Returns:
        smap:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    blocks=np.size(smap,0)
    step=int(np.sqrt(blocks))
 
    ThressBig=np.ndarray.flatten(ThressBigV)
    for x in range(blocksize):
        if ((ThressBig[x]&lt;ThressImg) and (ThressImg&lt;10)):
            ThressBig[x]=ThressImg
        elif ((ThressBig[x]&gt;ThressImg) and (ThressImg&lt;5)):
            ThressBig[x]=5
        for y in range(blocksize):
            if (ThressSmall[x,y]&lt;ThressBig[x]):
                if (ThressBig[x]&lt;5):
                    ThressSmall[x,y]=ThressBig[x]+1
                else:
                    ThressSmall[x,y]=ThressBig[x]
    Thresses=ThressSmall;
    increment = int(step/blocksize)
    for a in range(1,blocksize+1):
        Start=int(a*(blocks/blocksize)-(blocks/blocksize))
        End=int(a*(blocks/blocksize))-1
        
        for x in range(Start,End,step): 
            for y in range(increment):
                z=x+y
                if (a&lt;4):
                    if (smap[z,1]&lt; Thresses[0,(a*2)-2]):
                        smap[z,0]=59
                    if smap[z+increment,1]&lt;Thresses[0,a*2-1]:
                        smap[z+increment,0]=59
                    if smap[z+2*(increment),1]&lt;Thresses[1,(a*2)-2]:
                        smap[z+2*(increment),0]=59
                    if smap[z+3*(increment),1]&lt;Thresses[1,a*2-1]:
                        smap[z+3*(increment),0]=59
                    if smap[z+4*(increment),1]&lt;Thresses[2,(a*2)-2]:
                        smap[z+4*(increment),0]=59
                    if smap[z+5*(increment),1]&lt;Thresses[2,a*2-1]:
                        smap[z+5*(increment),0]=59
                else:
                    if smap[z,1]&lt; Thresses[3,((a-3)*2)-2]:
                        smap[z,0]=59
                    if smap[z+increment,1]&lt;Thresses[3,(a-3)*2-1]:
                        smap[z+increment,0]=59
                    if smap[z+2*(increment),1]&lt;Thresses[4,((a-3)*2)-2]:
                        smap[z+2*(increment),0]=59
                    if smap[z+3*(increment),1]&lt;Thresses[4,(a-3)*2-1]:
                        smap[z+3*(increment),0]=59
                    if smap[z+4*(increment),1]&lt;Thresses[5,((a-3)*2)-2]:
                        smap[z+4*(increment),0]=59;
                    if smap[z+5*(increment),1]&lt;Thresses[5,(a-3)*2-1]:
                        smap[z+5*(increment),0]=59
    return smap                        

def hist_adjust(arr,bins):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        arr:
        bins:
    
    Returns:
        [A,B]:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    [A,B]=np.histogram(arr,bins)
    for i in range(1,bins):
        count=np.count_nonzero(arr==B[i])
        A[i]-=count
        A[i-1]+=count
    return [A,B]

def inblockpatterns(image, bins, p, q, blk_idx, blk_idy):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        image:
        bins:
        p:
        q:
        blk_idx:
        blk_idy:
    
    Returns:
        K:
        Correct:
        BlockScoreAll: 

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    Zmat=np.zeros((int(np.floor(blk_idx*blk_idy)),2))
    a=-1
    BlockScoreAll = np.zeros((blk_idx,blk_idy))
    for i in range(blk_idx):
        Ax=(i*8)+p-1
        Ex=Ax+4
        for j in range(blk_idy):
            Ay=(j*8)+q-1
            A=image[Ax,Ay]
            B=image[Ax, Ay+1]
            C=image[Ax+1, Ay]
            D=image[Ax+1, Ay+1]
            
            Ey=Ay+4
            E=image[Ex, Ey]
            F=image[Ex, Ey+1]
            G=image[Ex+1, Ey]
            H=image[Ex+1, Ey+1]
            
            a+=1
            
            Zmat[a,0]=abs(A-B-C+D)
            Zmat[a,1]=abs(E-F-G+H)
            
            BlockScoreAll[i,j] = Zmat[a,1] - Zmat[a,0]
            if (BlockScoreAll[i,j]&lt;=0):
                BlockScoreAll[i,j]=0
    norm=a
    #Currently mismatched hist fcn
    Hz=hist_adjust(Zmat[:,0],bins)[0]
    Hzn=Hz/(norm+1)
    Hz2=hist_adjust(Zmat[:,1],bins)[0]
    Hz2n=Hz2/(norm+1)
    y2=int(Hzn.size)
    K=0
    for i in range(y2):
        K_temp=Hzn[i]-Hz2n[i]
        K+=abs(K_temp)
        
        
    A=sum(Hzn[0:2]);

    E=sum(Hz2n[0:2]);

    if A&gt;E:
        Correct=True;
    else:
        Correct=False;

    return [K,Correct, BlockScoreAll]


def predict0(Kscores):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        Kscores:
    
    Returns:
        Kpredict:
        Kpre:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    Kpredict=np.zeros((9,9))
    Kpredict[0:8,0:8]=Kscores[:,:,1]
    for i in range(8):
        Kpredict[8,i]=sum(Kpredict[:,i])
        Kpredict[i,8]=sum(Kpredict[i,:])
 
    Kpre=np.zeros((8,8))
    for i in range(8):
        for j in range(8):
            Kpre[i,j]=(Kpredict[i,8]+Kpredict[8,j])/16
    
    return [Kpredict, Kpre]

def predict1(Kscores,Kpredict,Kpre):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        Kscores:
        Kpredict:
        Kpre:

    Returns:

        PossiblePoints:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    A = np.zeros((4,4))
    for i in range(4):
        for j in range(4):
            A[i,j]=Kscores[i,j,0] + Kscores[i+4,j+4, 0] -Kscores[i+4,j,0]-Kscores[i,j+4,0]

    r1=[1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4]
    c1=[1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]

    PossiblePoints=np.zeros((len(r1),8));
    A_point = [0,0]
    E_point = [0,0]
    
    for i in range(len(r1)):
        r=r1[i]
        c=c1[i]
     
        if (A[r-1,c-1]&gt;0): 
            if (Kpredict[r-1,c-1]==1):
                A_point[0]=r
                A_point[1]=c
                E_point[0]=r+4
                E_point[1]=c+4
            else:
                E_point[0]=r;
                E_point[1]=c;
                A_point[0]=r+4;
                A_point[1]=c+4;
        else:
            if (Kpredict[r-1,c+3]==1):
                A_point[0]=r
                A_point[1]=c+4;
                E_point[0]=r+4;
                E_point[1]=c;   
            else:
                E_point[0]=r;
                E_point[1]=c+4;
                A_point[0]=r+4;
                A_point[1]=c;  
        PossiblePoints[i,0]= A_point[0];
        PossiblePoints[i,1]= A_point[1];
        PossiblePoints[i,2]= E_point[0];
        PossiblePoints[i,3]= E_point[1];

        PossiblePoints[i,4]= Kscores[r-1,c-1,0]/2;
        PossiblePoints[i,5]=0;  
 
    for i in range(len(r1)):
        PossiblePoints[i,6]=Kpre[int(PossiblePoints[i,0])-1,int(PossiblePoints[i,1])-1] -Kpre[int(PossiblePoints[i,2])-1,int(PossiblePoints[i,3])-1]
        PossiblePoints[i,7]=(PossiblePoints[i,6]  + PossiblePoints[i,4])/2                    
   
    return PossiblePoints 

def scores_pick_variables(BlockScoreALL,sgrid,blk_idx,blk_idy,PossiblePoints,kx,ky):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        BlockScoreAll:
        sgrid:
        blk_idx:
        blk_idy:
        PossiblePoints:
        kx:
        ky:

    Returns:
        MeanInSpace:
        PossiblePoints:
        diff_Mean_Best_scaled:
        diff_Mean_Best_scaledInv

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    
 
    BlockScore=np.zeros((blk_idx,blk_idy,16)) 
    for i in range(16):
        p=PossiblePoints[i,0]
        q=PossiblePoints[i,1]
        BlockScore[:,:,i]=BlockScoreALL[:,:,int(p-1),int(q-1)]/255

    MeanInSpace=np.zeros((kx,ky,16))
    for r in range(16):
        for i in range(kx):
            for j in range(ky):
                b=(i+1)*sgrid
                a=b-sgrid
                d=(j+1)*sgrid
                c=d-sgrid
                MeanInSpace[i,j,r]=np.mean(BlockScore[a:b,c:d,r])
               
    MeanOfAllGrids=np.mean(MeanInSpace,axis=2)
      
    BestGrid=MeanInSpace[:,:,15];
    diff_Mean_Best=MeanOfAllGrids - BestGrid
    diff_Mean_Best_scaled=mat2gray(diff_Mean_Best)
   
    bg=0;
    for f in range(16):
        if (PossiblePoints[f,0]==4 and PossiblePoints[f,1]==4):
            bg=f
            
    for f in range(16):
        if (bg==0):
            bg1= np.where(PossiblePoints[:,5]==max(PossiblePoints[:,5]))
            bg=np.max(bg1);
                   

    BestGridInv = np.zeros((kx,ky)) 
    BestGridInv=MeanInSpace[:,:,bg]
    diff_Mean_BestInv=MeanOfAllGrids - BestGridInv
    diff_Mean_Best_scaledInv=mat2gray(diff_Mean_BestInv)

    return [MeanInSpace,PossiblePoints,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv]

def CAGI(impath):
    &#34;&#34;&#34;
    Main driver for CAGI algorithm.    

    Args:
        impath: 

    Returns:
        Result_CAGI: Equivalent to OutputMap
        Result_Inv_CAGI: Other output of CAGI.
    &#34;&#34;&#34;        
    # Read image in as double RGB
    BGR=cv2.imread(impath)
    RGB=np.double(BGR[...,::-1])
    
    (height,width,color) = RGB.shape
    V_im=cv2.cvtColor(np.uint8(RGB), cv2.COLOR_RGB2HSV)[:,:,2]
    
    # Store the pixels for Y of YCbCr
    pixels=16/255+ (0.25678823529411759496454692452971 * RGB[:,:,0] + 0.50412941176470582593793778869440 * RGB[:,:,1] + 0.09790588235294117591678286771639 * RGB[:,:,2])
    
    if ((height*width)&lt;(480*640)):
        sgrid=2
    else:
        sgrid=3
    bins=40
    imageGS=pixels
    (x,y)=imageGS.shape
    blk_idx = int(np.floor((x/8)-1))
    blk_idy = int(np.floor((y/8)-1))
    kx = int(np.floor(blk_idx/sgrid))
    ky = int(np.floor(blk_idy/sgrid))
    BlockScoreAll = np.zeros((blk_idx,blk_idy, 8, 8))
    Kscores = np.zeros((8,8,2))
    for p in range(8):
        for q in range(8):
            (K, Correct, BlockScoreAll[:, :, p, q]) = inblockpatterns(imageGS, bins, p+1, q+1, blk_idx, blk_idy)
            if (K&gt;1.999999):
                Kscores[p, q, 0]=0
            else:
                Kscores[p,q,0]=K
            Kscores[p, q, 1]=Correct

    [Kpredict, Kpre] = predict0(Kscores)
    PossiblePoints = predict1(Kscores, Kpredict, Kpre)
    PossiblePoints = PossiblePoints[np.argsort(PossiblePoints[:,6])] 
    [MeanContent, MeanStrongEdge] = MainTrain(RGB, blk_idx, blk_idy)
    MeanContent2 = np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
            a = i*sgrid
            b=j*sgrid
            ccc=sgrid
            MeanContent2[i,j]=np.mean(MeanContent[a:a+ccc, b:b+ccc])
    [MeanInSpace,PossiblePoints,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv]=scores_pick_variables(BlockScoreAll,sgrid,blk_idx,blk_idy,PossiblePoints,kx,ky)
    
    [E,EInv]=characterizeblocks(MeanContent2,MeanStrongEdge, V_im, blk_idx,blk_idy, MeanInSpace,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv,sgrid,PossiblePoints,kx,ky)            
    Result_CAGI=RescaleToImageResult(E,sgrid,kx,ky,pixels)
    Result_Inv_CAGI=RescaleToImageResult(EInv,sgrid,kx,ky,pixels)
    
    return [Result_CAGI, Result_Inv_CAGI]


def getMasks():
    &#34;&#34;&#34;
    Return image masks.

    Args:

    Returns:
        PMasks:
        MMasks:
        MaskWhite:
    &#34;&#34;&#34;    
    
    PMasks = np.load(os.path.join(os.path.dirname(__file__),&#39;PMasks.npy&#39;))
    MMasks = np.load(os.path.join(os.path.dirname(__file__),&#39;MMasks.npy&#39;))
    MaskWhite = np.array([[10],
       [30],
       [50],
       [70],
       [90],
       [20],
       [40],
       [60],
       [80],
       [12],
       [30],
       [50],
       [70],
       [88],
       [15],
       [28],
       [45],
       [64],
       [79],
       [85],
       [12],
       [30],
       [50],
       [70],
       [88],
       [20],
       [40],
       [60],
       [80],
       [10],
       [30],
       [50],
       [70],
       [90],
       [20],
       [40],
       [60],
       [80],
       [12],
       [30],
       [50],
       [70],
       [88],
       [15],
       [21],
       [36],
       [55],
       [72],
       [85],
       [12],
       [30],
       [50],
       [70],
       [88],
       [20],
       [40],
       [60],
       [80]], dtype=np.uint8) 

    return [PMasks, MMasks, MaskWhite]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyIFD.CAGI.CAGI"><code class="name flex">
<span>def <span class="ident">CAGI</span></span>(<span>impath)</span>
</code></dt>
<dd>
<div class="desc"><p>Main driver for CAGI algorithm.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>impath</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Result_CAGI</code></dt>
<dd>Equivalent to OutputMap</dd>
<dt><code>Result_Inv_CAGI</code></dt>
<dd>Other output of CAGI.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def CAGI(impath):
    &#34;&#34;&#34;
    Main driver for CAGI algorithm.    

    Args:
        impath: 

    Returns:
        Result_CAGI: Equivalent to OutputMap
        Result_Inv_CAGI: Other output of CAGI.
    &#34;&#34;&#34;        
    # Read image in as double RGB
    BGR=cv2.imread(impath)
    RGB=np.double(BGR[...,::-1])
    
    (height,width,color) = RGB.shape
    V_im=cv2.cvtColor(np.uint8(RGB), cv2.COLOR_RGB2HSV)[:,:,2]
    
    # Store the pixels for Y of YCbCr
    pixels=16/255+ (0.25678823529411759496454692452971 * RGB[:,:,0] + 0.50412941176470582593793778869440 * RGB[:,:,1] + 0.09790588235294117591678286771639 * RGB[:,:,2])
    
    if ((height*width)&lt;(480*640)):
        sgrid=2
    else:
        sgrid=3
    bins=40
    imageGS=pixels
    (x,y)=imageGS.shape
    blk_idx = int(np.floor((x/8)-1))
    blk_idy = int(np.floor((y/8)-1))
    kx = int(np.floor(blk_idx/sgrid))
    ky = int(np.floor(blk_idy/sgrid))
    BlockScoreAll = np.zeros((blk_idx,blk_idy, 8, 8))
    Kscores = np.zeros((8,8,2))
    for p in range(8):
        for q in range(8):
            (K, Correct, BlockScoreAll[:, :, p, q]) = inblockpatterns(imageGS, bins, p+1, q+1, blk_idx, blk_idy)
            if (K&gt;1.999999):
                Kscores[p, q, 0]=0
            else:
                Kscores[p,q,0]=K
            Kscores[p, q, 1]=Correct

    [Kpredict, Kpre] = predict0(Kscores)
    PossiblePoints = predict1(Kscores, Kpredict, Kpre)
    PossiblePoints = PossiblePoints[np.argsort(PossiblePoints[:,6])] 
    [MeanContent, MeanStrongEdge] = MainTrain(RGB, blk_idx, blk_idy)
    MeanContent2 = np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
            a = i*sgrid
            b=j*sgrid
            ccc=sgrid
            MeanContent2[i,j]=np.mean(MeanContent[a:a+ccc, b:b+ccc])
    [MeanInSpace,PossiblePoints,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv]=scores_pick_variables(BlockScoreAll,sgrid,blk_idx,blk_idy,PossiblePoints,kx,ky)
    
    [E,EInv]=characterizeblocks(MeanContent2,MeanStrongEdge, V_im, blk_idx,blk_idy, MeanInSpace,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv,sgrid,PossiblePoints,kx,ky)            
    Result_CAGI=RescaleToImageResult(E,sgrid,kx,ky,pixels)
    Result_Inv_CAGI=RescaleToImageResult(EInv,sgrid,kx,ky,pixels)
    
    return [Result_CAGI, Result_Inv_CAGI]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.ImageTiling"><code class="name flex">
<span>def <span class="ident">ImageTiling</span></span>(<span>OImg)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>OImg:</p>
<h2 id="returns">Returns</h2>
<p>tile:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ImageTiling(OImg):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        OImg:

    Returns:
        tile:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    Img = np.array(Image.fromarray(OImg.astype(np.uint8)).resize(size=(600,600),resample=Image.NEAREST))
    R1=rgb2gray(Img)
    R=R1*255


    blocks=3600
    stepX=60
    stepY=60
    ImgR=R.astype(&#39;int&#39;)

    countx=-1
    tile=np.zeros((10,10,blocks))
    for a in range(stepX):
        for b in range(stepY):
            countx+=1
            i=-1
            for x in range((a*10),(a*10)+10):
                i+=1
                j=-1
                for y in range((b*10),(b*10)+10):
                    j+=1;
                    tile[i,j,countx]=ImgR[x,y]
                    
    return tile</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.MainTrain"><code class="name flex">
<span>def <span class="ident">MainTrain</span></span>(<span>R10, blk_idx, blk_idy)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>R10:
blk_idx:
blk_idy:</p>
<h2 id="returns">Returns</h2>
<p>MeanContent:
MeanStrongEdge:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def MainTrain(R10,blk_idx,blk_idy):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        R10:
        blk_idx:
        blk_idy:

    Returns:
        MeanContent:
        MeanStrongEdge:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    [x,y,z]=R10.shape
    [PMasks,MMasks,MaskWhite] = getMasks()
    #////////Image Tiling 3 Scales////////////////////////////
    #slight difference in tileF (~99% similarity)
    tileF=ImageTiling(R10)

    #////////////Smaping/////////////////////////////////////
    smapF=SmapIng(tileF, PMasks, MaskWhite)
    #% % % %////////////Filtering///////////////////////////////////
    [ThresSmall,ThresBig, ThresImg] =filtering(smapF)
    smapF_filtrOld=filteringMethod(smapF, ThresSmall, ThresBig, ThresImg)
    #Through here so far
    #/////////////PaintEdges///////////////////////////////// This uses NN PIL using mean
    [e,edge,contours]=PaintimgEdges(smapF_filtrOld, MMasks, 1)
    Output = np.array(Image.fromarray(e.astype(np.double)).resize(size=(y,x),resample=Image.NEAREST))
    StrongEdge = np.array(Image.fromarray(contours.astype(np.uint8)).resize(size=(y,x),resample=Image.NEAREST))


    MeanContent = np.zeros((blk_idx,blk_idy))
    MeanStrongEdge = np.zeros((blk_idx,blk_idy))
    for i in range(blk_idx):
        for j in range(blk_idy):
            a=i*8
            b=j*8
            MeanContent[i,j]=np.mean(Output[a:a+8, b:b+8])
            MeanStrongEdge[i,j]=np.mean(StrongEdge[a:a+8, b:b+8])
    MeanStrongEdge[MeanStrongEdge&gt;0.5]=1

    MeanStrongEdge[MeanStrongEdge&lt;=0.5]=0 
        

    return [MeanContent,MeanStrongEdge]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.PaintimgEdges"><code class="name flex">
<span>def <span class="ident">PaintimgEdges</span></span>(<span>smap, MMasks, scale)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>smap:
MMasks:
scale:</p>
<h2 id="returns">Returns</h2>
<p>edgeImg2:
edgeImg:
edgeImg3:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PaintimgEdges(smap, MMasks, scale):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        smap:
        MMasks:
        scale:

    Returns:
        edgeImg2:
        edgeImg:
        edgeImg3:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    if (scale==1):
        blocks=3600
        stepX=60
 
    edgeImg=np.zeros((600,600))
    edgeImg2=np.zeros((600,600))
    edgeImg3=np.zeros((600,600))
    countx=-1
    for a in range(stepX):
        for b in range(stepX):
            countx+=1
            i=-1
            for x in range(a*10,a*10+10):
                i+=1
                j=-1
                for y in range(b*10,b*10+10):
                    j+=1
                    edgeImg[x,y]=MMasks[i,j,int(smap[countx,0]-1)];
                    if (smap[countx,0]==59):
                        edgeImg3[x,y]=0
                    else:
                         edgeImg3[x,y]=1
                    edgeImg2[x,y]=smap[countx,1]
                    
    return [edgeImg2, edgeImg,edgeImg3]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.RescaleToImageResult"><code class="name flex">
<span>def <span class="ident">RescaleToImageResult</span></span>(<span>E, sgrid, kx, ky, pixels)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>E:
sgrid:
kx:
ky:
pixels:</p>
<h2 id="returns">Returns</h2>
<p>Result:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RescaleToImageResult(E,sgrid,kx,ky,pixels):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        E:
        sgrid:
        kx:
        ky:
        pixels:

    Returns:
        Result:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    result = np.zeros((kx*sgrid*8,ky*sgrid*8))
    for x in range(kx):
        for y in range(ky):
            a=x*sgrid*8
            b=y*sgrid*8
            result[a:a+sgrid*8,b:b+sgrid*8]  = E[x,y]
    [xim, yim]=pixels.shape
    [xres, yres]=result.shape
    Result=np.zeros((xim,yim))
    Result[:xres,:yres]=result

    for  k in range(xres,xim):
        for y in range(yres):
            Result[k, y]=result[xres-1,y]

    for k in range(xim):
        for y in range(yres,yim):
            Result[k, y]=Result[k,yres-1] # TODO Review yres here

    return Result</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.SmapIng"><code class="name flex">
<span>def <span class="ident">SmapIng</span></span>(<span>ImgTiles, MaskTiles, WhiteMaskPoints)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>ImgTiles:
MaskTiles:
WhiteMaskPoints:</p>
<h2 id="returns">Returns</h2>
<p>smap:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SmapIng(ImgTiles, MaskTiles, WhiteMaskPoints):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        ImgTiles:
        MaskTiles:
        WhiteMaskPoints:

    Returns:
        smap:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    blocks=np.shape(ImgTiles)[2]
    smap=np.zeros((blocks,2))
    winMask=59
    MaskWhite = (MaskTiles&gt;0).astype(int)
    MaskBlack = (MaskTiles&lt;=0).astype(int)

    for a in range(blocks): 
        maxR=0
        for k in range(58): 
            TempW = np.sum(ImgTiles[:,:,a]*MaskWhite[:,:,k])
            TempB = np.sum(ImgTiles[:,:,a]*MaskBlack[:,:,k])
            whiteScore=TempW/WhiteMaskPoints[k]
            blackScore=TempB/(100-WhiteMaskPoints[k])
            ctR=np.abs(whiteScore-blackScore)
            w=((ctR*100)/255)
            if (w&gt;maxR):
                maxR=w
                winMask=k+1

        smap[a,0]=winMask
        smap[a,1]=maxR

    return smap</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.characterizeblocks"><code class="name flex">
<span>def <span class="ident">characterizeblocks</span></span>(<span>MeanContent2, MeanStrongEdge, V_im, blk_idx, blk_idy, MeanInSpace, diff_Mean_Best_scaled, diff_Mean_Best_scaledInv, sgrid, PossiblePoints, kx, ky)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>MeanContent2:
MeanStrongEdge:
V_im:
blk_idx:
blk_idy:
MeanInSpace:
diff_Mean_Best_scaled:
diff_Mean_Best_scaledInv:
sgrid:
PossiblePoints:
kx:
ky:</p>
<h2 id="returns">Returns</h2>
<p>E:
EInv:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def characterizeblocks(MeanContent2,MeanStrongEdge, V_im, blk_idx,blk_idy, MeanInSpace,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv,sgrid,PossiblePoints,kx,ky):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        MeanContent2:
        MeanStrongEdge:
        V_im:
        blk_idx:
        blk_idy:
        MeanInSpace:
        diff_Mean_Best_scaled:
        diff_Mean_Best_scaledInv:
        sgrid:
        PossiblePoints:
        kx:
        ky:

    Returns:
        E:
        EInv:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    uniform=np.zeros((int(np.floor(blk_idx/sgrid)),int(np.floor(blk_idy/sgrid))))

    for a in range(kx):
        for b in range(ky):
            for pp in range(16):
                if (MeanInSpace[a,b,pp]&lt;(np.mean(MeanInSpace[:,:,pp]) *0.2)):
                    uniform[a,b]+=1
    
    st=np.std(np.reshape(uniform,(uniform.size,1),&#39;F&#39;))
    H =  np.ones((5,5))*0.04
    
    I=correlate(uniform,H,mode=&#39;constant&#39;)
    meanv=np.mean(I)             


    bg=0
    for f in range(16):
        if ((PossiblePoints[f,0]==4) and (PossiblePoints[f,1]==4)):
            bg=f+1
      
    if bg==16:
        bestgrid=mat2gray(correlate(MeanInSpace[:,:,15],H,mode=&#39;constant&#39;))
    elif bg==0:            
        bg1= np.where(PossiblePoints[:,4]==max(PossiblePoints[:,4]))  
        bg=np.max(bg1)+1
        bestgrid=mat2gray(correlate(MeanInSpace[:,:,bg-1],H,mode=&#39;constant&#39;))
    else:          
        bestgrid=mat2gray(correlate(MeanInSpace[:,:,bg],H,mode=&#39;constant&#39;))
#//////////block based homogenous
    if ((np.mean(PossiblePoints[:,4])&gt;0.4)  or (bg!=16)):
        homB=0
    else:
        homB=1
  
    if ((st/meanv)&gt;1.5):
        I[I&lt;(meanv+(st))]=0
        I[I&gt;=(meanv+(st))]=homB
    else:
        I[I&lt;(meanv+(st)/2)]=0
        I[I&gt;=(meanv+(st)/2)]=homB


#/////////no content////////////////////////


    contentsc=MeanContent2.copy()

    x24=np.floor(blk_idx/3)
    y24=np.floor(blk_idy/3)

    hom=np.zeros((kx,ky))
    held=np.mean(contentsc)
    for i in range(kx):
        for j in range(ky):
            if (contentsc[i,j]&lt;=4): #very soft responses
                hom[i,j]=1

    c=sgrid
    MeanStrongEdge2=np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
            a=i*sgrid
            b=j*sgrid
            MeanStrongEdge2[i,j]=np.mean(MeanStrongEdge[a:a+c, b:b+c])
    cc=8*sgrid
    V_im2=np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
            a=i*8*sgrid
            b=j*8*sgrid
            V_im2[i,j]=np.mean(V_im[a:a+cc, b:b+cc])

    V_imOver=V_im2.copy()
    V_imUndr=V_im2.copy()
    V_imOver[V_imOver&gt;=245]=300
    V_imOver[V_imOver!=300]=0
    V_imUndr[V_imUndr&lt;15]=300
    V_imUndr[V_imUndr!=300]=0
    V_imOver=mat2gray(V_imOver)
    V_imUndr=mat2gray(V_imUndr)
    MeanStrongEdge2[MeanStrongEdge2&lt;0.5]=0
    MeanStrongEdge2[MeanStrongEdge2&gt;=0.5]=1
    #/////////////end overexposed/iunder and contours////////////////////

    touse=kx*ky
    notuse=np.zeros((kx,ky))
    for i in range(kx):
        for j in range(ky):
      
            if hom[i,j]==1:
                notuse[i,j]=3
            if MeanStrongEdge2[i,j]==1:
                notuse[i,j]=2         
            if ((V_imUndr[i,j]==1) or (V_imOver[i,j]==1)):
                notuse[i,j]=1

    for i in range(kx):
        for j in range(ky):   
            if notuse[i,j]==1:
                I[i,j]=1
    
    notused=np.sum(notuse[:]!=0)
    touse=kx*ky-notused
#//////////////excl NaN

    if touse==0:
        for i in range(kx):
            for j in range(ky):
                if  hom[i,j]==1 and I[i,j]!=1:
                    notuse[i,j]=0

    diff_Mean_Best_scaled_temp=diff_Mean_Best_scaled.copy()
    diff_Mean_Best_scaled_tempInv=diff_Mean_Best_scaledInv.copy()
    for a in range(int(np.floor(blk_idx/sgrid))):
        for b in range(int(np.floor(blk_idy/sgrid))):
            if I[a,b]==1:
                diff_Mean_Best_scaled_temp[a,b]=0
                diff_Mean_Best_scaled_tempInv[a,b]=1
            if diff_Mean_Best_scaled_temp[a,b]&lt;np.mean(diff_Mean_Best_scaled) and homB==1:
                diff_Mean_Best_scaled_temp[a,b]=0
            if diff_Mean_Best_scaled_tempInv[a,b]&lt;np.mean(diff_Mean_Best_scaledInv)and homB==1:
                diff_Mean_Best_scaled_tempInv[a,b]=1

    a+=1
    b+=1
    imageF = np.zeros((a,b))
    imageFInv = np.zeros((a,b))
    for x in range(a):
        for y in range(b):
            if x==0 or x==a-1 or y==0 or y==b-1:
                imageF[x,y]=diff_Mean_Best_scaled_temp[x,y]*(bestgrid[x,y])
            else:
                imageF[x,y]=diff_Mean_Best_scaled_temp[x,y]*(1-bestgrid[x,y])
            imageFInv[x,y]=diff_Mean_Best_scaled_tempInv[x,y]*(1-bestgrid[x,y])
         
    E_nofilt=imageF.copy()
    E=correlate(imageF, H,mode=&#39;constant&#39;)
          
    E_nofiltInv=imageFInv.copy()
    EInv=correlate(imageFInv, H,mode=&#39;constant&#39;)
    # /////////////content based filtering//////////
    uninteresting=np.zeros((touse,1))
    uninterestingInv=np.zeros((touse,1))
    a=-1
    for i in range(kx):
        for j in range(ky):
            if(notuse[i,j]==0):
                a+=1
                uninteresting[a]=E[i,j]
                uninterestingInv[a]=EInv[i,j] 
    MeanBlocksre=E_nofilt.copy()
    MeanBlocksreInv=E_nofiltInv.copy()
    meanuninteresting=np.mean(uninteresting)
    meanuninterestingInv=np.mean(uninterestingInv)
    for i in range(kx):
        for j in range(ky):
            if ((I[i,j]==1) and (notuse[i,j]==2)):
                I[i,j]=0
            if ((notuse[i,j]==1) or (MeanBlocksre[i,j]&lt;meanuninteresting)):
                MeanBlocksre[i,j]=meanuninteresting
            if (((I[i,j]==1) and (MeanBlocksre[i,j]&lt;meanuninteresting )) or  ((notuse[i,j]==3) and (I[i,j]==1))):
                MeanBlocksre[i,j]=meanuninteresting
            if ((notuse[i,j]==1) or (MeanBlocksreInv[i,j]&gt;meanuninterestingInv)):
                MeanBlocksreInv[i,j]=meanuninterestingInv
            if (((I[i,j]==1)  and (MeanBlocksreInv[i,j]&gt;meanuninterestingInv)) or ((notuse[i,j]==3) and (I[i,j]==1))):
                MeanBlocksreInv[i,j]=meanuninterestingInv
    E=correlate(MeanBlocksre, H,mode=&#39;reflect&#39;) 
    EInv=correlate(MeanBlocksreInv, H,mode=&#39;reflect&#39;) 
            
    return [E, EInv]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.filtering"><code class="name flex">
<span>def <span class="ident">filtering</span></span>(<span>smap)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>smap:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>meansmallAreas:</dt>
<dt>meanbigAreas:</dt>
<dt><code>meanImg</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filtering(smap):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        smap:

    Returns:
        meansmallAreas:
        meanbigAreas:
        meanImg: 

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    blocks=np.shape(smap)[0]
    step=np.int(np.sqrt(blocks))
    smallAreas=np.zeros((blocksize,blocksize))
    increment=np.int(step/blocksize)
    for a in range(blocksize):
        Start=np.int((a+1)*(blocks/blocksize)-(blocks/blocksize)+1)
        End=np.int((a+1)*(blocks/blocksize))
        for x in range(Start,End,step):
            for y in range(increment):
                z=x+y-1
                if (a&lt;3):
                    smallAreas[0,a*2]=smallAreas[0,a*2]+smap[z,1]
                    smallAreas[0,a*2+1]=smallAreas[0,a*2+1]+smap[z+increment,1]

                    smallAreas[1,(a*2)]=smallAreas[1,(a*2)]+smap[z+2*(increment),1]
                    smallAreas[1,a*2+1]=smallAreas[1,a*2+1]+smap[z+3*(increment),1]
                
                    smallAreas[2,a*2]=smallAreas[2,a*2]+smap[z+4*(increment),1]
                    smallAreas[2,a*2+1]=smallAreas[2,a*2+1]+smap[z+5*(increment),1]
                else: 
                    smallAreas[3,((a-3)*2)]=smallAreas[3,((a-3)*2)]+smap[z,1]
                    smallAreas[3,(a-3)*2+1]=smallAreas[3,(a-3)*2+1]+smap[z+increment,1]
                
                    smallAreas[4,((a-3)*2)]=smallAreas[4,((a-3)*2)]+smap[z+2*(increment),1]
                    smallAreas[4,(a-3)*2+1]=smallAreas[4,(a-3)*2+1]+smap[z+3*(increment),1]
                
                    smallAreas[5,((a-3)*2)]=smallAreas[5,((a-3)*2)]+smap[z+4*(increment),1]
                    smallAreas[5,(a-3)*2+1]=smallAreas[5,(a-3)*2+1]+smap[z+5*(increment),1]
    meansmallAreas=smallAreas/100
    meanbigAreas=np.zeros((1,blocksize))
    for x in range(blocksize):
        meanbigAreas[0,x]=np.mean(meansmallAreas[x,:])
    meanImg=np.mean(meanbigAreas)

    return [meansmallAreas, meanbigAreas, meanImg]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.filteringMethod"><code class="name flex">
<span>def <span class="ident">filteringMethod</span></span>(<span>smap, ThressSmall, ThressBigV, ThressImg)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>smap:
ThressSmall:
ThressBigV:
ThressImg:</p>
<h2 id="returns">Returns</h2>
<p>smap:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filteringMethod (smap, ThressSmall, ThressBigV, ThressImg):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        smap:
        ThressSmall:
        ThressBigV:
        ThressImg:

    Returns:
        smap:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    blocks=np.size(smap,0)
    step=int(np.sqrt(blocks))
 
    ThressBig=np.ndarray.flatten(ThressBigV)
    for x in range(blocksize):
        if ((ThressBig[x]&lt;ThressImg) and (ThressImg&lt;10)):
            ThressBig[x]=ThressImg
        elif ((ThressBig[x]&gt;ThressImg) and (ThressImg&lt;5)):
            ThressBig[x]=5
        for y in range(blocksize):
            if (ThressSmall[x,y]&lt;ThressBig[x]):
                if (ThressBig[x]&lt;5):
                    ThressSmall[x,y]=ThressBig[x]+1
                else:
                    ThressSmall[x,y]=ThressBig[x]
    Thresses=ThressSmall;
    increment = int(step/blocksize)
    for a in range(1,blocksize+1):
        Start=int(a*(blocks/blocksize)-(blocks/blocksize))
        End=int(a*(blocks/blocksize))-1
        
        for x in range(Start,End,step): 
            for y in range(increment):
                z=x+y
                if (a&lt;4):
                    if (smap[z,1]&lt; Thresses[0,(a*2)-2]):
                        smap[z,0]=59
                    if smap[z+increment,1]&lt;Thresses[0,a*2-1]:
                        smap[z+increment,0]=59
                    if smap[z+2*(increment),1]&lt;Thresses[1,(a*2)-2]:
                        smap[z+2*(increment),0]=59
                    if smap[z+3*(increment),1]&lt;Thresses[1,a*2-1]:
                        smap[z+3*(increment),0]=59
                    if smap[z+4*(increment),1]&lt;Thresses[2,(a*2)-2]:
                        smap[z+4*(increment),0]=59
                    if smap[z+5*(increment),1]&lt;Thresses[2,a*2-1]:
                        smap[z+5*(increment),0]=59
                else:
                    if smap[z,1]&lt; Thresses[3,((a-3)*2)-2]:
                        smap[z,0]=59
                    if smap[z+increment,1]&lt;Thresses[3,(a-3)*2-1]:
                        smap[z+increment,0]=59
                    if smap[z+2*(increment),1]&lt;Thresses[4,((a-3)*2)-2]:
                        smap[z+2*(increment),0]=59
                    if smap[z+3*(increment),1]&lt;Thresses[4,(a-3)*2-1]:
                        smap[z+3*(increment),0]=59
                    if smap[z+4*(increment),1]&lt;Thresses[5,((a-3)*2)-2]:
                        smap[z+4*(increment),0]=59;
                    if smap[z+5*(increment),1]&lt;Thresses[5,(a-3)*2-1]:
                        smap[z+5*(increment),0]=59
    return smap                        </code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.getMasks"><code class="name flex">
<span>def <span class="ident">getMasks</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return image masks.</p>
<p>Args:</p>
<h2 id="returns">Returns</h2>
<p>PMasks:
MMasks:
MaskWhite:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getMasks():
    &#34;&#34;&#34;
    Return image masks.

    Args:

    Returns:
        PMasks:
        MMasks:
        MaskWhite:
    &#34;&#34;&#34;    
    
    PMasks = np.load(os.path.join(os.path.dirname(__file__),&#39;PMasks.npy&#39;))
    MMasks = np.load(os.path.join(os.path.dirname(__file__),&#39;MMasks.npy&#39;))
    MaskWhite = np.array([[10],
       [30],
       [50],
       [70],
       [90],
       [20],
       [40],
       [60],
       [80],
       [12],
       [30],
       [50],
       [70],
       [88],
       [15],
       [28],
       [45],
       [64],
       [79],
       [85],
       [12],
       [30],
       [50],
       [70],
       [88],
       [20],
       [40],
       [60],
       [80],
       [10],
       [30],
       [50],
       [70],
       [90],
       [20],
       [40],
       [60],
       [80],
       [12],
       [30],
       [50],
       [70],
       [88],
       [15],
       [21],
       [36],
       [55],
       [72],
       [85],
       [12],
       [30],
       [50],
       [70],
       [88],
       [20],
       [40],
       [60],
       [80]], dtype=np.uint8) 

    return [PMasks, MMasks, MaskWhite]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.hist_adjust"><code class="name flex">
<span>def <span class="ident">hist_adjust</span></span>(<span>arr, bins)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>arr:
bins:</p>
<h2 id="returns">Returns</h2>
<p>[A,B]:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hist_adjust(arr,bins):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        arr:
        bins:
    
    Returns:
        [A,B]:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    [A,B]=np.histogram(arr,bins)
    for i in range(1,bins):
        count=np.count_nonzero(arr==B[i])
        A[i]-=count
        A[i-1]+=count
    return [A,B]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.im2double"><code class="name flex">
<span>def <span class="ident">im2double</span></span>(<span>im)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts image to type double.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>im</code></strong></dt>
<dd>Input image</dd>
</dl>
<p>Returns:
image as double: Converts type of im to double. Scales so elements lie from 0 to 1.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def im2double(im):
    &#34;&#34;&#34;
    Converts image to type double.

    Args:
        im: Input image

    Returns: 
        image as double: Converts type of im to double. Scales so elements lie from 0 to 1.
    &#34;&#34;&#34;
    info = np.iinfo(im.dtype) 
    return im.astype(np.double) / info.max </code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.inblockpatterns"><code class="name flex">
<span>def <span class="ident">inblockpatterns</span></span>(<span>image, bins, p, q, blk_idx, blk_idy)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>image:
bins:
p:
q:
blk_idx:
blk_idy:</p>
<h2 id="returns">Returns</h2>
<dl>
<dt>K:</dt>
<dt>Correct:</dt>
<dt><code>BlockScoreAll</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inblockpatterns(image, bins, p, q, blk_idx, blk_idy):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        image:
        bins:
        p:
        q:
        blk_idx:
        blk_idy:
    
    Returns:
        K:
        Correct:
        BlockScoreAll: 

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    Zmat=np.zeros((int(np.floor(blk_idx*blk_idy)),2))
    a=-1
    BlockScoreAll = np.zeros((blk_idx,blk_idy))
    for i in range(blk_idx):
        Ax=(i*8)+p-1
        Ex=Ax+4
        for j in range(blk_idy):
            Ay=(j*8)+q-1
            A=image[Ax,Ay]
            B=image[Ax, Ay+1]
            C=image[Ax+1, Ay]
            D=image[Ax+1, Ay+1]
            
            Ey=Ay+4
            E=image[Ex, Ey]
            F=image[Ex, Ey+1]
            G=image[Ex+1, Ey]
            H=image[Ex+1, Ey+1]
            
            a+=1
            
            Zmat[a,0]=abs(A-B-C+D)
            Zmat[a,1]=abs(E-F-G+H)
            
            BlockScoreAll[i,j] = Zmat[a,1] - Zmat[a,0]
            if (BlockScoreAll[i,j]&lt;=0):
                BlockScoreAll[i,j]=0
    norm=a
    #Currently mismatched hist fcn
    Hz=hist_adjust(Zmat[:,0],bins)[0]
    Hzn=Hz/(norm+1)
    Hz2=hist_adjust(Zmat[:,1],bins)[0]
    Hz2n=Hz2/(norm+1)
    y2=int(Hzn.size)
    K=0
    for i in range(y2):
        K_temp=Hzn[i]-Hz2n[i]
        K+=abs(K_temp)
        
        
    A=sum(Hzn[0:2]);

    E=sum(Hz2n[0:2]);

    if A&gt;E:
        Correct=True;
    else:
        Correct=False;

    return [K,Correct, BlockScoreAll]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.mat2gray"><code class="name flex">
<span>def <span class="ident">mat2gray</span></span>(<span>A)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts matrix to have values from 0-1.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>A</code></strong></dt>
<dd>Input matrix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Gray matrix with values from 0-1.</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mat2gray(A):
    &#34;&#34;&#34;
    Converts matrix to have values from 0-1.

    Args:
        A: Input matrix.

    Returns:
        Gray matrix with values from 0-1.

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    A-=A.min()
    if(A.max()==0):
        return A
    return A/A.max()</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.predict0"><code class="name flex">
<span>def <span class="ident">predict0</span></span>(<span>Kscores)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>Kscores:</p>
<h2 id="returns">Returns</h2>
<p>Kpredict:
Kpre:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict0(Kscores):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        Kscores:
    
    Returns:
        Kpredict:
        Kpre:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;
    Kpredict=np.zeros((9,9))
    Kpredict[0:8,0:8]=Kscores[:,:,1]
    for i in range(8):
        Kpredict[8,i]=sum(Kpredict[:,i])
        Kpredict[i,8]=sum(Kpredict[i,:])
 
    Kpre=np.zeros((8,8))
    for i in range(8):
        for j in range(8):
            Kpre[i,j]=(Kpredict[i,8]+Kpredict[8,j])/16
    
    return [Kpredict, Kpre]</code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.predict1"><code class="name flex">
<span>def <span class="ident">predict1</span></span>(<span>Kscores, Kpredict, Kpre)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>Kscores:
Kpredict:
Kpre:</p>
<h2 id="returns">Returns</h2>
<p>PossiblePoints:</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict1(Kscores,Kpredict,Kpre):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        Kscores:
        Kpredict:
        Kpre:

    Returns:

        PossiblePoints:

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    A = np.zeros((4,4))
    for i in range(4):
        for j in range(4):
            A[i,j]=Kscores[i,j,0] + Kscores[i+4,j+4, 0] -Kscores[i+4,j,0]-Kscores[i,j+4,0]

    r1=[1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4]
    c1=[1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4]

    PossiblePoints=np.zeros((len(r1),8));
    A_point = [0,0]
    E_point = [0,0]
    
    for i in range(len(r1)):
        r=r1[i]
        c=c1[i]
     
        if (A[r-1,c-1]&gt;0): 
            if (Kpredict[r-1,c-1]==1):
                A_point[0]=r
                A_point[1]=c
                E_point[0]=r+4
                E_point[1]=c+4
            else:
                E_point[0]=r;
                E_point[1]=c;
                A_point[0]=r+4;
                A_point[1]=c+4;
        else:
            if (Kpredict[r-1,c+3]==1):
                A_point[0]=r
                A_point[1]=c+4;
                E_point[0]=r+4;
                E_point[1]=c;   
            else:
                E_point[0]=r;
                E_point[1]=c+4;
                A_point[0]=r+4;
                A_point[1]=c;  
        PossiblePoints[i,0]= A_point[0];
        PossiblePoints[i,1]= A_point[1];
        PossiblePoints[i,2]= E_point[0];
        PossiblePoints[i,3]= E_point[1];

        PossiblePoints[i,4]= Kscores[r-1,c-1,0]/2;
        PossiblePoints[i,5]=0;  
 
    for i in range(len(r1)):
        PossiblePoints[i,6]=Kpre[int(PossiblePoints[i,0])-1,int(PossiblePoints[i,1])-1] -Kpre[int(PossiblePoints[i,2])-1,int(PossiblePoints[i,3])-1]
        PossiblePoints[i,7]=(PossiblePoints[i,6]  + PossiblePoints[i,4])/2                    
   
    return PossiblePoints </code></pre>
</details>
</dd>
<dt id="pyIFD.CAGI.scores_pick_variables"><code class="name flex">
<span>def <span class="ident">scores_pick_variables</span></span>(<span>BlockScoreALL, sgrid, blk_idx, blk_idy, PossiblePoints, kx, ky)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill me in please.</p>
<h2 id="args">Args</h2>
<p>BlockScoreAll:
sgrid:
blk_idx:
blk_idy:
PossiblePoints:
kx:
ky:</p>
<h2 id="returns">Returns</h2>
<p>MeanInSpace:
PossiblePoints:
diff_Mean_Best_scaled:
diff_Mean_Best_scaledInv</p>
<h2 id="todos">Todos</h2>
<ul>
<li>Fill this in with proper summary</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scores_pick_variables(BlockScoreALL,sgrid,blk_idx,blk_idy,PossiblePoints,kx,ky):
    &#34;&#34;&#34;
    Fill me in please.

    Args:
        BlockScoreAll:
        sgrid:
        blk_idx:
        blk_idy:
        PossiblePoints:
        kx:
        ky:

    Returns:
        MeanInSpace:
        PossiblePoints:
        diff_Mean_Best_scaled:
        diff_Mean_Best_scaledInv

    Todos:
        * Fill this in with proper summary
    &#34;&#34;&#34;    
    
 
    BlockScore=np.zeros((blk_idx,blk_idy,16)) 
    for i in range(16):
        p=PossiblePoints[i,0]
        q=PossiblePoints[i,1]
        BlockScore[:,:,i]=BlockScoreALL[:,:,int(p-1),int(q-1)]/255

    MeanInSpace=np.zeros((kx,ky,16))
    for r in range(16):
        for i in range(kx):
            for j in range(ky):
                b=(i+1)*sgrid
                a=b-sgrid
                d=(j+1)*sgrid
                c=d-sgrid
                MeanInSpace[i,j,r]=np.mean(BlockScore[a:b,c:d,r])
               
    MeanOfAllGrids=np.mean(MeanInSpace,axis=2)
      
    BestGrid=MeanInSpace[:,:,15];
    diff_Mean_Best=MeanOfAllGrids - BestGrid
    diff_Mean_Best_scaled=mat2gray(diff_Mean_Best)
   
    bg=0;
    for f in range(16):
        if (PossiblePoints[f,0]==4 and PossiblePoints[f,1]==4):
            bg=f
            
    for f in range(16):
        if (bg==0):
            bg1= np.where(PossiblePoints[:,5]==max(PossiblePoints[:,5]))
            bg=np.max(bg1);
                   

    BestGridInv = np.zeros((kx,ky)) 
    BestGridInv=MeanInSpace[:,:,bg]
    diff_Mean_BestInv=MeanOfAllGrids - BestGridInv
    diff_Mean_Best_scaledInv=mat2gray(diff_Mean_BestInv)

    return [MeanInSpace,PossiblePoints,diff_Mean_Best_scaled,diff_Mean_Best_scaledInv]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyIFD" href="index.html">pyIFD</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyIFD.CAGI.CAGI" href="#pyIFD.CAGI.CAGI">CAGI</a></code></li>
<li><code><a title="pyIFD.CAGI.ImageTiling" href="#pyIFD.CAGI.ImageTiling">ImageTiling</a></code></li>
<li><code><a title="pyIFD.CAGI.MainTrain" href="#pyIFD.CAGI.MainTrain">MainTrain</a></code></li>
<li><code><a title="pyIFD.CAGI.PaintimgEdges" href="#pyIFD.CAGI.PaintimgEdges">PaintimgEdges</a></code></li>
<li><code><a title="pyIFD.CAGI.RescaleToImageResult" href="#pyIFD.CAGI.RescaleToImageResult">RescaleToImageResult</a></code></li>
<li><code><a title="pyIFD.CAGI.SmapIng" href="#pyIFD.CAGI.SmapIng">SmapIng</a></code></li>
<li><code><a title="pyIFD.CAGI.characterizeblocks" href="#pyIFD.CAGI.characterizeblocks">characterizeblocks</a></code></li>
<li><code><a title="pyIFD.CAGI.filtering" href="#pyIFD.CAGI.filtering">filtering</a></code></li>
<li><code><a title="pyIFD.CAGI.filteringMethod" href="#pyIFD.CAGI.filteringMethod">filteringMethod</a></code></li>
<li><code><a title="pyIFD.CAGI.getMasks" href="#pyIFD.CAGI.getMasks">getMasks</a></code></li>
<li><code><a title="pyIFD.CAGI.hist_adjust" href="#pyIFD.CAGI.hist_adjust">hist_adjust</a></code></li>
<li><code><a title="pyIFD.CAGI.im2double" href="#pyIFD.CAGI.im2double">im2double</a></code></li>
<li><code><a title="pyIFD.CAGI.inblockpatterns" href="#pyIFD.CAGI.inblockpatterns">inblockpatterns</a></code></li>
<li><code><a title="pyIFD.CAGI.mat2gray" href="#pyIFD.CAGI.mat2gray">mat2gray</a></code></li>
<li><code><a title="pyIFD.CAGI.predict0" href="#pyIFD.CAGI.predict0">predict0</a></code></li>
<li><code><a title="pyIFD.CAGI.predict1" href="#pyIFD.CAGI.predict1">predict1</a></code></li>
<li><code><a title="pyIFD.CAGI.scores_pick_variables" href="#pyIFD.CAGI.scores_pick_variables">scores_pick_variables</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>